# Вопрос №1
# На языке Python написать алгоритм (функцию) определения четности целого числа, который
# будет аналогичен нижеприведенному по функциональности, но отличен по своей сути.
# Объяснить плюсы и минусы обеих реализаций.
#
# Пример:
#
# def isEven(value):
#       return value % 2 == 0

import time
import pytest


# 1) реализация через битовую операцию AND: если последний бит 0 - число четное, 1 - нечетное
# пример четного:
#   10:  1 0 1 0
#    1:  0 0 0 1
# ----------------
#  AND:  0 0 0 0

# пример нечетного:
#   11:  1 0 1 1
#    1:  0 0 0 1
# ----------------
#  AND:  0 0 0 1
def isEven_bit(value):
    return value & 1 == 0


# 2) реализация через получения остатка от деления: если остаток 0 - число четное, 1 - нечетное
# пример четного:
# 10 % 2 = 0 (тк 10 / 2 = 5)
# 11 % 2 = 1 (11 / 2 = 5.5 => 5 + остаток 1)
def isEven_modul(value):
    return value % 2 == 0


# Демонстрация, что функция isEven_bit работает быстрее чем isEven_modul.
# Вычисление четности числа будет с использованием AND будет работать быстрее чем деление с остатком
# тк битовые операции делаются непосредственно на уровне битов, в то время как % - более сложная ариф. операция
# для больших чисел скорость выполнения алгоритма будет существенна.
@pytest.mark.parametrize("function", [isEven_bit, isEven_modul])
def test_performance(function):
    value = 100000000
    start_time = time.time()
    result = function(value)
    end_time = time.time()
    execution_time = end_time - start_time
    print("\nВремя выполнения для {} составило: {} секунды".format(function.__name__, execution_time))

    assert result


# запуск теста
if __name__ == "__main__":
    pytest.main()

# РЕЗУЛЬТАТ ВЫПОЛНЕНИЯ:
# first_task.py::test_performance[isEven_bit] PASSED                       [ 50%]
# Время выполнения для isEven_bit составило: 2.384185791015625e-07 секунды
#
# first_task.py::test_performance[isEven_modul] PASSED                     [100%]
# Время выполнения для isEven_modul составило: 9.5367431640625e-07 секунды
